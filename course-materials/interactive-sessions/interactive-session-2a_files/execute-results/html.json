{
  "hash": "3cebe7bf5ba21c225e0cf46fa502f9eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Interactive Session 2A\"\nsubtitle: \"Data types & indexing\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n# Part 1: Setup\n\n- Create a repo on GitHub called `eds221-day2-comp`\n- Clone to make a version-controlled R Project\n- Create a new Quarto Markdown, saved in the root as `r-data-types`\n- Create a new Jupyter Notebook, saved in the root as `py-data-types`\n\n# Part 2: Making & indexing data in R\n\n## Vectors!\n\n### Making vectors\n\n#### A character vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs <- c(\"teddy\", \"khora\", \"waffle\", \"banjo\")\n\ntypeof(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n#### A numeric vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweights <- c(50, 55, 25, 35)\n\ntypeof(weights) # Hmmm what is different about this and the line below?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(weights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n#### An integer vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndog_age <- c(5L, 6L, 1L, 7L)\n\ntypeof(dog_age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dog_age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check with a logical: \nis.numeric(dog_age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n#### What if we combine classes? \n\nThere is a hierarchy of classes. The broadest of all in a vector wins (if there are characters, then character will be the class of the entire vector).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndog_info <- c(\"teddy\", 50, 5L)\ndog_info\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"teddy\" \"50\"    \"5\"    \n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dog_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dog_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(dog_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n#### Named elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndog_food <- c(teddy = \"purina\", khora = \"alpo\", waffle = \"fancy feast\", banjo = \"blue diamond\")\ndog_food\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         teddy          khora         waffle          banjo \n      \"purina\"         \"alpo\"  \"fancy feast\" \"blue diamond\" \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dog_food)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dog_food)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n### Accessing bits of vectors\n\nUse `[]` with the position or name to access elements of a vector. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndog_food[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n khora \n\"alpo\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndog_food[\"khora\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n khora \n\"alpo\" \n```\n\n\n:::\n:::\n\n\nOr we can specify a range of values within a vector using `[:]`. The first element in **R vectors is assigned element = 1.** This is an important distinction. In Python, the first element is assigned 0 (zero-index). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector of car colors observed\ncars <- c(\"red\", \"orange\", \"white\", \"blue\", \"green\", \"silver\", \"black\")\n\n# Access just the 5th element\ncars[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"green\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access elements 2 through 4\ncars[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"orange\" \"white\"  \"blue\"  \n```\n\n\n:::\n:::\n\n\n### A warm-up for for loops:\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 4\ncars[i]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"blue\"\n```\n\n\n:::\n\n```{.r .cell-code}\ni <- seq(1:3)\ncars[i]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"red\"    \"orange\" \"white\" \n```\n\n\n:::\n:::\n\n\n### And we can update elements of a vector directly (mutable):\n\n::: {.cell}\n\n```{.r .cell-code}\ncars[3] <- \"BURRITOS!\"\ncars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"red\"       \"orange\"    \"BURRITOS!\" \"blue\"      \"green\"     \"silver\"   \n[7] \"black\"    \n```\n\n\n:::\n:::\n\n\n\n## Matrices!\n\n### Creating matrices \n\n(...we did some of this in EDS 212 too!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfish_size <- matrix(c(0.8, 1.2, 0.4, 0.9), ncol = 2, nrow = 2, byrow = FALSE)\n\nfish_size\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]  0.8  0.4\n[2,]  1.2  0.9\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(fish_size) # Returns the class of values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(fish_size) # Returns matrix / array\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\nWhat happens if we try to combine multiple data types into a matrix?\n\n::: {.cell}\n\n```{.r .cell-code}\ndog_walk <- matrix(c(\"teddy\", 5, \"khora\", 10), ncol = 2, nrow = 2, byrow = FALSE)\n\ndog_walk\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]    [,2]   \n[1,] \"teddy\" \"khora\"\n[2,] \"5\"     \"10\"   \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dog_walk)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dog_walk)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Hmmmmmm once again back to the broadest category of data type in the hierarchy\n```\n:::\n\n\n### Accessing pieces of matrices\n\nIndex using `[row, column]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhale_travel <- matrix(data = c(31.8, 1348, 46.9, 1587), nrow = 2, ncol = 2, byrow = TRUE)\n\n# Take a look\nwhale_travel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,] 31.8 1348\n[2,] 46.9 1587\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access the value 1348\nwhale_travel[1,2] # Row 1, column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1348\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access the value 46.9\nwhale_travel[2,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 46.9\n```\n\n\n:::\n:::\n\n\nIf you leave any element blank (keeping the comma), it will return all values from the other element. For example, to get everything in row 2:\n\n::: {.cell}\n\n```{.r .cell-code}\nwhale_travel[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   46.9 1587.0\n```\n\n\n:::\n:::\n\n\nOr, to access everything in column 1: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhale_travel[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.8 46.9\n```\n\n\n:::\n:::\n\n\nWhat happens if I only give a matrix one element? That's the position in the matrix *as if populated by column.* Check out a few:\n\n::: {.cell}\n\n```{.r .cell-code}\nwhale_travel[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1348\n```\n\n\n:::\n:::\n\n\n## Lists\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurchins <- list(\"blue\", c(1, 2, 3), c(\"a cat\", \"a dog\"), 5L)\n\nurchins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"blue\"\n\n[[2]]\n[1] 1 2 3\n\n[[3]]\n[1] \"a cat\" \"a dog\"\n\n[[4]]\n[1] 5\n```\n\n\n:::\n:::\n\n### Accessing pieces of a list\n\nImportant: a single [] returns a list. [[]] returns the item STORED in the list. \n\n::: {.cell}\n\n```{.r .cell-code}\nurchins[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Compare that to: \nurchins[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n### Naming list items? Sure thing! \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntacos <- list(topping = c(\"onion\", \"cilantro\", \"guacamole\"), filling = c(\"beans\", \"meat\", \"veggie\"), price = c(6.75, 8.25, 9.50))\n\n# The whole thing\ntacos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$topping\n[1] \"onion\"     \"cilantro\"  \"guacamole\"\n\n$filling\n[1] \"beans\"  \"meat\"   \"veggie\"\n\n$price\n[1] 6.75 8.25 9.50\n```\n\n\n:::\n\n```{.r .cell-code}\n# Just get one piece of it: \ntacos[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"beans\"  \"meat\"   \"veggie\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#...or, the same thing:\ntacos$filling\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"beans\"  \"meat\"   \"veggie\"\n```\n\n\n:::\n:::\n\n\n## Data frames \n\nA data frame is a list containing vectors of the same length, where each column is a variable stored in a vector. Let's make one: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit <- data.frame(type = c(\"apple\", \"banana\", \"peach\"), \n                    mass = c(130, 195, 150))\n\n# Look at it\nfruit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    type mass\n1  apple  130\n2 banana  195\n3  peach  150\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check the class\nclass(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n### Access elements from a data frame\n\nUse [row#, col#], or name the column (then element number).\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 130\n```\n\n\n:::\n\n```{.r .cell-code}\nfruit[3,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"peach\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit[2,1] <- \"pineapple\"\nfruit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       type mass\n1     apple  130\n2 pineapple  195\n3     peach  150\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}